#!/usr/bin/env python
import signal
import time
import logging, logging.handlers
import importlib
import inspect
import json
import os

from collections import namedtuple
from bisect import insort

from daemon import DaemonContext
from znappy import models, keyvalue

logging.basicConfig(format="%(asctime)s [%(name)-24.24s] [%(funcName)-16.16s] [%(levelname)-8.8s] %(message)s")
logger = logging.getLogger(__name__)
logging.getLogger().addHandler(logging.handlers.SysLogHandler(address='/dev/log', facility=logging.handlers.SysLogHandler.LOG_DAEMON))
logging.getLogger('urllib3.connectionpool').setLevel(logging.WARNING)

class PrioritizedHandler(namedtuple('PrioritizedHandler', ('priority','driver','callback'))):
    def __lt__(self, other):
        return self.priority < other.priority


class ZnappyEventException(Exception):
    pass


class ZnappyDaemon(object):
    def __init__(self, db, cluster = 'default'):
        self.db           = db
        self.cluster_name = cluster

        self.load_cluster()
        self.load_config()


    def load_cluster(self):
        self.cluster  = models.Cluster(self.cluster_name)

        if not self.db.node in self.cluster.hosts:
            self.host = models.Host(db.node, self.cluster)
            self.host.save()
        else:
            self.host     = self.cluster.hosts[self.db.node]


    def load_config(self):
        index, data = self.db.get('service/znappy/config')

        logger.debug(data)

        if data:
            self.config = json.loads(data['Value'])
        else:
            self.config = {}


    def load_drivers(self):
        self.handlers = {}
        drivers = self.config.get('drivers', {})

        for driver in drivers.keys():
            try:
                pkg = importlib.import_module(driver)

                # TODO I wanna get rid of this parameter so I don't need
                # reload all the drivers on each run
                pkg.load_handlers(drivers[driver], self.snapshot, register=self.register)
            except (ImportError, Exception), e:
                raise e
                logger.warn("Failed to load driver: {}.. skipping".format(e.message))


    def check_update(self):
        if self.host.snapshots:
            last = max(self.host.snapshots, key=lambda s: s.time)

            if last.time > int(time.time() - self.config.get('snapshot', {'min_age': 3600})['min_age']):
                logger.debug('last snapshot is ok')
                return False

        return True


    def clean_snapshots(self):
        drivers = self.config.get('drivers', [])
        logger.debug('cleaning old snapshots')
        logger.debug(drivers)

        for driver in drivers:
            snapshots = filter(lambda s: s.driver == driver, self.host.snapshots)
            logger.debug(snapshots)
            snapshots = sorted(snapshots, key=lambda s: s.time, reverse=True)
            logger.debug(snapshots)

            self.execute_event(['delete_snapshot'], driver, snapshots)


    def register(self, event, handler, priority=0):
        caller = inspect.getmodule(inspect.stack()[1][0]).__name__
        logger.debug("caller: {0}, event: {1}, priority {2}, handler={3}".format(caller,event,priority, handler))

        handler = PrioritizedHandler(priority, caller, handler)

        event_handlers = self.handlers.setdefault(event, [])
        insort(event_handlers, handler)


    def execute_event(self, events, driver = None, *args, **kwargs):
        matching_handlers = []

        for e in list(events) + ["all"]:
            matching_handlers += self.handlers.get(e, [])

        matching_handlers = sorted(matching_handlers)

        if driver:
            matching_handlers = filter(lambda h: h.driver == driver, matching_handlers)

        logger.debug("[{2}] {0} => {1}".format(list(events), matching_handlers, driver))

        for handler in matching_handlers:
            result, message = self.execute_handler(handler, *args, **kwargs)

            if not result:
                logger.critical("Failed to execute handler: handlers={0}, message={1}".format(handlers, message))
                raise ZnappyEventException()


    def execute_handler(self, handler, *args, **kwargs):
        try:
            return handler.callback(*args, **kwargs)
        except Exception, e:
            logger.warn(e.message)
            return False, ''


    def run(self):
        self.running = True

        while self.running:
            self.snapshot = models.Snapshot(None, self.host)    
            self.load_cluster()
            self.load_drivers()

            logger.debug(self.handlers)

            if self.check_update() and self.cluster.lock():
                self.runner()
                self.cluster.release()

            self.db.ping()
            time.sleep(3)

        logger.debug('ending..')
        self.db.close()

    def runner(self):
        try:
            self.execute_event(['pre_snapshot'])
            self.execute_event(['start_snapshot'])
            self.execute_event(['create_snapshot'])
            self.execute_event(['save_snapshot'])
        except Exception, e:
            logger.warn(e)
        finally:
            self.execute_event(['end_snapshot'])
            self.execute_event(['post_snapshot'])

        self.clean_snapshots()

    def stop(self, sig, frame):
        self.running = False

        return True


cluster_name = os.environ.get('ZNAPPY_CLUSTER', 'default')
consul_host  = os.environ.get('ZNAPPY_CONSUL', 'localhost')
debug_level  = os.environ.get('ZNAPPY_DEBUG_LEVEL', 'INFO')

logging.getLogger().setLevel(debug_level)

db = keyvalue.KeyValue(host=consul_host)

with db:
    models.db = db

    agent = ZnappyDaemon(db, cluster=cluster_name)

    signal.signal(signal.SIGINT, agent.stop)

    agent.run()
